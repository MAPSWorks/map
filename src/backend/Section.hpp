/**
 * @file	Skeleton.hpp 
 * @author	Jesús Carabaño Bravo <jcaraban@abo.fi>
 *
 */

#ifndef MAP_RUNTIME_SECTION_HPP_
#define MAP_RUNTIME_SECTION_HPP_

#include "util.hpp"
#include "../visitor/Visitor.hpp"
#include <unordered_map>
#include <vector>
#include <set>
#include <map>
#include <queue>


namespace map { namespace detail {

struct Skeleton; // Forward declaration
struct Section; // Forward declaration

typedef std::vector<std::unique_ptr<Section>> OwnerSectionList;
typedef std::vector<Section*> SectionList;

struct NodeExtension {
	Node *node;
	DataSize ext;
	bool operator==(const NodeExtension &other) const {
		return node == other.node;// && all(ext == othe8r.ext);
	}
	bool operator<(const NodeExtension &other) const {
		return node->id < other.node->id;
	}
};

#define DECLARE_VISIT(class) virtual void visit(class *node);

/*
 * Section of the kernel code delimiting a set of related operations
 * Such operations present common 'pattern', 'dimension' and 'reach'
 */
struct Section : public Visitor
{
	static Section* Factory(DataSize ext, Pattern pat, Skeleton *skel);
	//virtual Section* clone() = 0; // no needed so far

	const NodeList& nodeList() const;
	const SectionList& prevList() const;
	const SectionList& nextList() const;

	bool extendedReach() const;
	NumDim numdim() const;
	
	void add(Pattern pat);
	void sub(Pattern pat);
	bool is(Pattern pat) const;
	bool isNot(Pattern pat) const;

	bool operator==(const Section &section) const;
	bool operator>(const Section &section) const;
	bool operator<(const Section &section) const;

	struct Hash {
		std::size_t operator()(const Section *k) const;
	};
	struct Greater {
		bool operator()(const Section *lhs, const Section *rhs) const;
	};
	struct Equal {
		bool operator()(const Section *lhs, const Section *rhs) const;
	};

	std::string indent();
	std::string indented(std::string code);
	std::string format(std::string str);
	void add_line(std::string str);

  // codegen
	void fill();
	virtual std::string section();
	std::string generateCode();
	std::string input_section();
	std::string cpu_input_section(); // @
	std::string output_section();
	std::string free_section();
	std::string local_section();
	std::string focal_section();
	std::string zonal_section();
	std::string cpu_zonal_section(); // @
	std::string stats_section();
	std::string reduc_section();
	std::string merge_section();
	std::string switch_section();

  // visit
	virtual void visit_input(Node *node);
	virtual void visit_output(Node *node);
	DECLARE_VISIT(Constant)
	DECLARE_VISIT(Empty)
	DECLARE_VISIT(Index)
	DECLARE_VISIT(Identity)
	DECLARE_VISIT(Rand)
	DECLARE_VISIT(Cast)
	DECLARE_VISIT(Unary)
	DECLARE_VISIT(Binary)
	DECLARE_VISIT(Conditional)
	DECLARE_VISIT(Diversity)
	DECLARE_VISIT(Neighbor)
	DECLARE_VISIT(BoundedNeighbor)
	DECLARE_VISIT(SpreadNeighbor)
	DECLARE_VISIT(Convolution)
	DECLARE_VISIT(FocalFunc)
	DECLARE_VISIT(FocalPercent)
	DECLARE_VISIT(ZonalReduc)
	DECLARE_VISIT(RadialScan)
	DECLARE_VISIT(SpreadScan)
	DECLARE_VISIT(LoopCond)
	DECLARE_VISIT(LoopHead)
	DECLARE_VISIT(LoopTail)
	DECLARE_VISIT(Merge)
	DECLARE_VISIT(Switch)
	DECLARE_VISIT(Access)
	DECLARE_VISIT(LhsAccess)
	DECLARE_VISIT(Read)
	DECLARE_VISIT(Write)
	DECLARE_VISIT(Scalar)
	DECLARE_VISIT(Temporal)
	DECLARE_VISIT(Checkpoint)
	DECLARE_VISIT(Barrier)
	DECLARE_VISIT(Summary)
	DECLARE_VISIT(DataSummary)
	DECLARE_VISIT(BlockSummary)
	DECLARE_VISIT(GroupSummary)

  // vars
	Pattern pat; //!< Absolute position according to the section pattern
	//Pattern prev, next; //!< Relative position according to prev-next patterns
	DataSize ext; //!< Extension of the 'spatial reach' needed in this section
	DeviceType dev;
	Skeleton *skel;

	NodeList node_list; //!< Stores the 'nodes' belonging to a 'section'
	SectionList next_list;
	SectionList prev_list;

	std::string code; //!< The code generated by the nodes
	int indent_count;

	std::vector<std::string> include;

	std::vector<NodeExtension> ext_shared; //!< Nodes accessed in extended spatial e.g. Focal inputs
	std::vector<std::pair<Node*,int>> shared; //!< Stores pairs {node,size} for nodes requiring shared-mem chunks
	std::vector<std::pair<Mask,int>> mask; //!< Stores pairs {mask,id}

	std::vector<Diversity*> diver; //!< Stores diversity nodes
	std::vector<RadialScan*> radia; //!< Stores RadialScan nodes
	//std::vector<Rand*> rand; //!< Stores rand nodes
	std::vector<Merge*> merge_list;
	std::vector<Switch*> switch_list;
	std::vector<SkelReduc> reduc_list; //!< Stores reductions nodes
};

#undef DECLARE_VISIT

} } // namespace map::detail

#endif
