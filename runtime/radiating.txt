const bool west = BC0 < SC0;
const bool east = BC0 > SC0;
const bool north = BC1 < SC1;
const bool south = BC1 > SC1;

const bool fst_west = west && dif0 >= dif1;
const bool snd_west = west && dif0 < dif1;
const bool fst_east = east && dif0 >= dif1;
const bool snd_east = east && dif0 < dif1;
const bool fst_north = north && dif1 > dif0;
const bool snd_north = north && dif1 <= dif0;
const bool fst_south = south && dif1 > dif0;
const bool snd_south = south && dif1 <= dif0;

const int fst_dim0 = fst_east || fst_west;
const int fst_dim1 = fst_south || fst_north;
const int snd_dim0 = snd_east || snd_west;
const int snd_dim1 = snd_south || snd_north;
const int fst_unit0 = fst_east - fst_west;
const int fst_unit1 = fst_south - fst_north;
const int snd_unit0 = snd_east - snd_west;
const int snd_unit1 = snd_south - snd_north;

float interpolate_float(float a, float b, int sc0, int sc1, int dc0, int dc1) {
	const int fst_unit0 = fst_east - fst_west;
	const int fst_unit1 = fst_south - fst_north;
	const int snd_unit0 = snd_east - snd_west;
	const int snd_unit1 = snd_south - snd_north;

	int dif0 = abs(sc0 - dc0);
	int dif1 = abs(sc1- dc1);
	dif0 = dif0 * fst_unit0 + dif1 * fst_unit1;
	dif1 = dif1 * snd_unit1 + dif0 * snd_unit0;
	float w = dif1 / dif0 * (dif0 - 1.0f) - (dif1 - 1.0f);
	return a * w + b * (1.0f-w);
}

kernel void radiating
(
	global float *IN_0,
	TYPE_VAR_LIST(OUT_3,float),
	global bool *OUT_4,
	const int BS0,
	const int BS1,
	const int BC0,
	const int BC1,
	const int GS0,
	const int GS1,
	const int sc0,
	const int sc1
)
{
	float F32_0, F32_2, F32_3;
	int S32_1;
	bool B8_4;
	local float F32S_3[256+1];

	const int limit0 = BS0 * fst_dim0 + BS1 * fst_dim1;
	const int limit1 = iceil(BS0 * snd_dim0 + BS1 * snd_dim1, GS1);

	const int dc0 = BC0*BS0 * fst_east + ((BC0+1)*BS0-1) * fst_west;
	const int dc1 = BC1*BS1 * fst_south + ((BC1+1)*BS1-1) * fst_north;
	
	const int bc0 = 0 * fst_east + (BS0-1) * fst_west;
	const int bc1 = 0 * fst_south + (BS1-1) * fst_north;

	const int gc0 = get_local_id(0);

	for (int d1=0; d1<limit1; d1++) { // 2nd dim FOR
		for (int d0=0; d0<limit0; d0++) // 1st dim FOR
		{
			// Previous to RADIATING core

			if (bc0 < BS0 && bc1 < BS1)
			{
				F32_0 = IN_0[(bc1)*BS0+bc0];
				F32_1 = 1;
				F32_2 = F32_0 + F32_1;
			}
			
			// RADIATING core

			if (bc0 < BS0 && bc1 < BS1)
			{
				int c0 = bc0 - fst_unit0;
				int c1 = bc1 - fst_unit1;
				F32S_3[gc0+1] = load_float(VAR_LIST(OUT_3),c0,c1,BS0,BS1);

				if (gc0 == 0) {
					int c0 = bc0 - fst_unit0 - snd_unit0;
					int c1 = bc1 - fst_unit1 - snd_unit1;
					F32S_3[gc0] = load_float(VAR_LIST(OUT),c0,c1,BS0,BS1);
				}
			}
			barrier(CLK_LOCAL_MEM_FENCE);

			if (bc0 < BS0 && bc1 < BS1)
			{
				F32_3 = interpolate_float(F32S_3[gc0],F32S_3[gc0+1],sc0,sc1,dc0,dc1);
				F32_3 = max(F32_2,F32_3);
				F32S_3[gc0+1] = F32_3;

				if (gc0 == 0) {
					int c0 = bc0 - fst_unit0 - snd_unit0;
					int c1 = bc1 - fst_unit1 - snd_unit1;
					F32S_3[gc0] = load_float(VAR_LIST(OUT),c0,c1,BS0,BS1);
				}
			}
		
			if (bc0 < BS0 && bc1 < BS1)
			{
				OUT_3[(bc1)*BS0+bc0] = F32_3;
			}

			// Posterior to RADIATING core

			if (bc0 < BS0 && bc1 < BS1)
			{
				B8_4 = F32_3 < F32_1;
				OUT_4[(bc1)*BS0+bc0] = B8_4;
			}
		} // end 1st dim FOR
	} // end 2nd dim FOR
}
